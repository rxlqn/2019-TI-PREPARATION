; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\bsp_modbus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\bsp_modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\Flash\Obj\bsp_modbus.crf ..\..\User\bsp_stm32f4xx\src\bsp_modbus.c]
                          THUMB

                          AREA ||i.MODBUS_01H||, CODE, READONLY, ALIGN=1

                  MODBUS_01H PROC
;;;209    */
;;;210    static void MODBUS_01H(void)
000000  4770              BX       lr
;;;211    {
;;;212    }
;;;213    
                          ENDP


                          AREA ||i.MODBUS_02H||, CODE, READONLY, ALIGN=1

                  MODBUS_02H PROC
;;;221    */
;;;222    static void MODBUS_02H(void)
000000  4770              BX       lr
;;;223    {
;;;224    
;;;225    }
;;;226    
                          ENDP


                          AREA ||i.MODBUS_03H||, CODE, READONLY, ALIGN=1

                  MODBUS_03H PROC
;;;234    */
;;;235    static void MODBUS_03H(void)
000000  4770              BX       lr
;;;236    {
;;;237    
;;;238    }
;;;239    
                          ENDP


                          AREA ||i.MODBUS_04H||, CODE, READONLY, ALIGN=1

                  MODBUS_04H PROC
;;;247    */
;;;248    static void MODBUS_04H(void)
000000  4770              BX       lr
;;;249    {
;;;250    
;;;251    }
;;;252    
                          ENDP


                          AREA ||i.MODBUS_05H||, CODE, READONLY, ALIGN=1

                  MODBUS_05H PROC
;;;260    */
;;;261    static void MODBUS_05H(void)
000000  4770              BX       lr
;;;262    {
;;;263    
;;;264    }
;;;265    
                          ENDP


                          AREA ||i.MODBUS_06H||, CODE, READONLY, ALIGN=1

                  MODBUS_06H PROC
;;;274    
;;;275    static void MODBUS_06H(void)
000000  4770              BX       lr
;;;276    {
;;;277    
;;;278    }
;;;279    
                          ENDP


                          AREA ||i.MODBUS_10H||, CODE, READONLY, ALIGN=1

                  MODBUS_10H PROC
;;;288    */
;;;289    static void MODBUS_10H(void)
000000  4770              BX       lr
;;;290    {
;;;291    
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.MODBUS_AnalyzeApp||, CODE, READONLY, ALIGN=2

                  MODBUS_AnalyzeApp PROC
;;;303    */
;;;304    void MODBUS_AnalyzeApp(void)
000000  b510              PUSH     {r4,lr}
;;;305    {
;;;306    	/* Modbus从机 */
;;;307    	switch (g_tModbus.RxBuf[1])			/* 第2个字节 功能码 */
000002  4817              LDR      r0,|L8.96|
000004  7840              LDRB     r0,[r0,#1]  ; g_tModbus
000006  2804              CMP      r0,#4
000008  d017              BEQ      |L8.58|
00000a  dc06              BGT      |L8.26|
00000c  2801              CMP      r0,#1
00000e  d00b              BEQ      |L8.40|
000010  2802              CMP      r0,#2
000012  d00c              BEQ      |L8.46|
000014  2803              CMP      r0,#3
000016  d11c              BNE      |L8.82|
000018  e00c              B        |L8.52|
                  |L8.26|
00001a  2805              CMP      r0,#5
00001c  d010              BEQ      |L8.64|
00001e  2806              CMP      r0,#6
000020  d011              BEQ      |L8.70|
000022  2810              CMP      r0,#0x10
000024  d115              BNE      |L8.82|
000026  e011              B        |L8.76|
                  |L8.40|
;;;308    	{
;;;309    		case 0x01:	/* 读取线圈状态（对应远程开关D01/D02/D03） */
;;;310    			MODBUS_01H();
000028  f7fffffe          BL       MODBUS_01H
;;;311    			break;
00002c  e016              B        |L8.92|
                  |L8.46|
;;;312    
;;;313    		case 0x02:	/* 读取输入状态（对应T01～T18） */
;;;314    			MODBUS_02H();
00002e  f7fffffe          BL       MODBUS_02H
;;;315    			break;
000032  e013              B        |L8.92|
                  |L8.52|
;;;316    
;;;317    		case 0x03:	/* 读取保持寄存器 在一个或多个保持寄存器中取得当前的二进制值 */
;;;318    			MODBUS_03H();
000034  f7fffffe          BL       MODBUS_03H
;;;319    			break;
000038  e010              B        |L8.92|
                  |L8.58|
;;;320    
;;;321    		case 0x04:	/* 读取输入寄存器（对应A01/A02） ） */
;;;322    			MODBUS_04H();
00003a  f7fffffe          BL       MODBUS_04H
;;;323    			break;
00003e  e00d              B        |L8.92|
                  |L8.64|
;;;324    
;;;325    		case 0x05:	/* 强制单线圈（对应D01/D02/D03） */
;;;326    			MODBUS_05H();
000040  f7fffffe          BL       MODBUS_05H
;;;327    			break;
000044  e00a              B        |L8.92|
                  |L8.70|
;;;328    
;;;329    		case 0x06:	/* 写单个寄存器 (存储在EEPROM中的参数) */
;;;330    			MODBUS_06H();
000046  f7fffffe          BL       MODBUS_06H
;;;331    			break;
00004a  e007              B        |L8.92|
                  |L8.76|
;;;332    
;;;333    		case 0x10:	/* 写多个寄存器 （改写时钟） */
;;;334    			MODBUS_10H();
00004c  f7fffffe          BL       MODBUS_10H
;;;335    			break;
000050  e004              B        |L8.92|
                  |L8.82|
;;;336    
;;;337    		default:
;;;338    			g_tModbus.RspCode = RSP_ERR_CMD;
000052  2001              MOVS     r0,#1
000054  4902              LDR      r1,|L8.96|
000056  f881010c          STRB     r0,[r1,#0x10c]
;;;339    			//MODBUS_SendAckErr(g_tModbus.RspCode);	/* 告诉主机命令错误 */
;;;340    			break;
00005a  bf00              NOP      
                  |L8.92|
00005c  bf00              NOP                            ;311
;;;341    	}
;;;342    }
00005e  bd10              POP      {r4,pc}
;;;343    
                          ENDP

                  |L8.96|
                          DCD      g_tModbus

                          AREA ||i.MODBUS_InitVar||, CODE, READONLY, ALIGN=2

                  MODBUS_InitVar PROC
;;;31     */
;;;32     void MODBUS_InitVar(uint32_t _Baud, uint8_t _WorkMode)
000000  b570              PUSH     {r4-r6,lr}
;;;33     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;34     	g_rtu_timeout = 0;
000006  2000              MOVS     r0,#0
000008  4907              LDR      r1,|L9.40|
00000a  7008              STRB     r0,[r1,#0]
;;;35     	g_tModbus.RxCount = 0;
00000c  4907              LDR      r1,|L9.44|
00000e  f8810080          STRB     r0,[r1,#0x80]
;;;36     
;;;37     	g_tModbus.Baud = _Baud;
000012  4608              MOV      r0,r1
000014  f8c04108          STR      r4,[r0,#0x108]  ; g_tModbus
;;;38     
;;;39     	g_tModbus.WorkMode = WKM_NO_CRC;	/* 接收数据帧不进行CRC校验 */
000018  2000              MOVS     r0,#0
00001a  f881018e          STRB     r0,[r1,#0x18e]
;;;40     
;;;41     	bsp_Set485Baud(_Baud);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       bsp_Set485Baud
;;;42     }
000024  bd70              POP      {r4-r6,pc}
;;;43     
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      g_rtu_timeout
                  |L9.44|
                          DCD      g_tModbus

                          AREA ||i.MODBUS_Poll||, CODE, READONLY, ALIGN=2

                  MODBUS_Poll PROC
;;;51     */
;;;52     void MODBUS_Poll(void)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54     	uint16_t crc1;
;;;55     
;;;56     	if (g_rtu_timeout == 0)
000002  4831              LDR      r0,|L10.200|
000004  7800              LDRB     r0,[r0,#0]  ; g_rtu_timeout
000006  b900              CBNZ     r0,|L10.10|
                  |L10.8|
;;;57     	{
;;;58     		/* 没有超时，继续接收。不要清零 g_tModbus.RxCount */
;;;59     		return;
;;;60     	}
;;;61     
;;;62     	/* 收到命令
;;;63     		05 06 00 88 04 57 3B70 (8 字节)
;;;64     			05    :  数码管屏的号站，
;;;65     			06    :  指令
;;;66     			00 88 :  数码管屏的显示寄存器
;;;67     			04 57 :  数据,,,转换成 10 进制是 1111.高位在前,
;;;68     			3B70  :  二个字节 CRC 码	从05到 57的校验
;;;69     	*/
;;;70     	g_rtu_timeout = 0;
;;;71     
;;;72     	switch (g_tModbus.WorkMode)
;;;73     	{
;;;74     		case WKM_NO_CRC:	/* 接收数据帧不进行CRC校验. 用于ASCII协议 */
;;;75     			{
;;;76     				/* 将接收的数据复制到另外一个缓冲区，等待APP程序读取 */
;;;77     				memcpy(g_tModbus.AppRxBuf, g_tModbus.RxBuf, g_tModbus.RxCount);
;;;78     				g_tModbus.AppRxCount = g_tModbus.RxCount;
;;;79     				bsp_PutKey(MSG_485_RX);		/* 借用按键FIFO，发送一个收到485数据帧的消息 */
;;;80     			}
;;;81     			break;
;;;82     
;;;83     		case WKM_MODBUS_HOST:			/* Modbus 主机模式 */
;;;84     			if (g_tModbus.RxCount < 4)
;;;85     			{
;;;86     				goto err_ret;
;;;87     			}
;;;88     
;;;89     			/* 计算CRC校验和 */
;;;90     			crc1 = CRC16_Modbus(g_tModbus.RxBuf, g_tModbus.RxCount);
;;;91     			if (crc1 != 0)
;;;92     			{
;;;93     				goto err_ret;
;;;94     			}
;;;95     
;;;96     			/* 站地址 (1字节） */
;;;97     			g_tModbus.AppRxAddr = g_tModbus.RxBuf[0];	/* 第1字节 站号 */
;;;98     
;;;99     			/* 将接收的数据复制到另外一个缓冲区，等待APP程序读取 */
;;;100    			memcpy(g_tModbus.AppRxBuf, g_tModbus.RxBuf, g_tModbus.RxCount);
;;;101    			g_tModbus.AppRxCount = g_tModbus.RxCount;
;;;102    			bsp_PutKey(MSG_485_RX);		/* 借用按键FIFO，发送一个收到485数据帧的消息 */
;;;103    			break;
;;;104    
;;;105    		case WKM_MODBUS_DEVICE:			/* Modbus 从机模式 */
;;;106    			if (g_tModbus.RxCount < 4)
;;;107    			{
;;;108    				goto err_ret;
;;;109    			}
;;;110    
;;;111    			/* 计算CRC校验和 */
;;;112    			crc1 = CRC16_Modbus(g_tModbus.RxBuf, g_tModbus.RxCount);
;;;113    			if (crc1 != 0)
;;;114    			{
;;;115    				goto err_ret;
;;;116    			}
;;;117    
;;;118    			/* 站地址 (1字节） */
;;;119    			g_tModbus.AppRxAddr = g_tModbus.RxBuf[0];	/* 第1字节 站号 */
;;;120    
;;;121    			/* 分析应用层协议 */
;;;122    			MODBUS_AnalyzeApp();
;;;123    			break;
;;;124    
;;;125    		default:
;;;126    			break;
;;;127    	}
;;;128    
;;;129    err_ret:
;;;130    	g_tModbus.RxCount = 0;	/* 必须清零计数器，方便下次帧同步 */
;;;131    }
000008  bd10              POP      {r4,pc}
                  |L10.10|
00000a  2000              MOVS     r0,#0                 ;70
00000c  492e              LDR      r1,|L10.200|
00000e  7008              STRB     r0,[r1,#0]            ;70
000010  482e              LDR      r0,|L10.204|
000012  f890018e          LDRB     r0,[r0,#0x18e]        ;72  ; g_tModbus
000016  b120              CBZ      r0,|L10.34|
000018  2801              CMP      r0,#1                 ;72
00001a  d013              BEQ      |L10.68|
00001c  2802              CMP      r0,#2                 ;72
00001e  d14a              BNE      |L10.182|
000020  e033              B        |L10.138|
                  |L10.34|
000022  482a              LDR      r0,|L10.204|
000024  f8902080          LDRB     r2,[r0,#0x80]         ;77  ; g_tModbus
000028  4601              MOV      r1,r0                 ;77
00002a  3083              ADDS     r0,r0,#0x83           ;77
00002c  f7fffffe          BL       __aeabi_memcpy
000030  4826              LDR      r0,|L10.204|
000032  f8900080          LDRB     r0,[r0,#0x80]         ;78  ; g_tModbus
000036  4925              LDR      r1,|L10.204|
000038  f8810103          STRB     r0,[r1,#0x103]        ;78
00003c  20fe              MOVS     r0,#0xfe              ;79
00003e  f7fffffe          BL       bsp_PutKey
000042  e039              B        |L10.184|
                  |L10.68|
000044  4821              LDR      r0,|L10.204|
000046  f8900080          LDRB     r0,[r0,#0x80]         ;84  ; g_tModbus
00004a  2804              CMP      r0,#4                 ;84
00004c  da00              BGE      |L10.80|
00004e  e035              B        |L10.188|
                  |L10.80|
000050  481e              LDR      r0,|L10.204|
000052  f8901080          LDRB     r1,[r0,#0x80]         ;90  ; g_tModbus
000056  f7fffffe          BL       CRC16_Modbus
00005a  4604              MOV      r4,r0                 ;90
00005c  b104              CBZ      r4,|L10.96|
00005e  e02d              B        |L10.188|
                  |L10.96|
000060  481a              LDR      r0,|L10.204|
000062  7800              LDRB     r0,[r0,#0]            ;97  ; g_tModbus
000064  4919              LDR      r1,|L10.204|
000066  f8810104          STRB     r0,[r1,#0x104]        ;97
00006a  4608              MOV      r0,r1                 ;100
00006c  f8902080          LDRB     r2,[r0,#0x80]         ;100  ; g_tModbus
000070  3083              ADDS     r0,r0,#0x83           ;100
000072  f7fffffe          BL       __aeabi_memcpy
000076  4815              LDR      r0,|L10.204|
000078  f8900080          LDRB     r0,[r0,#0x80]         ;101  ; g_tModbus
00007c  4913              LDR      r1,|L10.204|
00007e  f8810103          STRB     r0,[r1,#0x103]        ;101
000082  20fe              MOVS     r0,#0xfe              ;102
000084  f7fffffe          BL       bsp_PutKey
000088  e016              B        |L10.184|
                  |L10.138|
00008a  4810              LDR      r0,|L10.204|
00008c  f8900080          LDRB     r0,[r0,#0x80]         ;106  ; g_tModbus
000090  2804              CMP      r0,#4                 ;106
000092  da00              BGE      |L10.150|
000094  e012              B        |L10.188|
                  |L10.150|
000096  480d              LDR      r0,|L10.204|
000098  f8901080          LDRB     r1,[r0,#0x80]         ;112  ; g_tModbus
00009c  f7fffffe          BL       CRC16_Modbus
0000a0  4604              MOV      r4,r0                 ;112
0000a2  b104              CBZ      r4,|L10.166|
0000a4  e00a              B        |L10.188|
                  |L10.166|
0000a6  4809              LDR      r0,|L10.204|
0000a8  7800              LDRB     r0,[r0,#0]            ;119  ; g_tModbus
0000aa  4908              LDR      r1,|L10.204|
0000ac  f8810104          STRB     r0,[r1,#0x104]        ;119
0000b0  f7fffffe          BL       MODBUS_AnalyzeApp
0000b4  e000              B        |L10.184|
                  |L10.182|
0000b6  bf00              NOP                            ;126
                  |L10.184|
0000b8  bf00              NOP                            ;81
0000ba  bf00              NOP                            ;129
                  |L10.188|
0000bc  2000              MOVS     r0,#0                 ;130
0000be  4903              LDR      r1,|L10.204|
0000c0  f8810080          STRB     r0,[r1,#0x80]         ;130
0000c4  bf00              NOP      
0000c6  e79f              B        |L10.8|
;;;132    
                          ENDP

                  |L10.200|
                          DCD      g_rtu_timeout
                  |L10.204|
                          DCD      g_tModbus

                          AREA ||i.MODBUS_ReciveNew||, CODE, READONLY, ALIGN=2

                  MODBUS_ReciveNew PROC
;;;140    */
;;;141    void MODBUS_ReciveNew(uint8_t _byte)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
000002  4604              MOV      r4,r0
;;;143    	/*
;;;144    		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;145    		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;146    		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;147    
;;;148            4800  = 7.297ms
;;;149            9600  = 3.646ms
;;;150            19200  = 1.771ms
;;;151            38400  = 0.885ms
;;;152    	*/
;;;153    	uint32_t timeout;
;;;154    
;;;155    	timeout = 35000000 / g_tModbus.Baud;		/* 计算超时时间，单位us */
000004  480d              LDR      r0,|L11.60|
000006  f8d00108          LDR      r0,[r0,#0x108]  ; g_tModbus
00000a  490d              LDR      r1,|L11.64|
00000c  fbb1f5f0          UDIV     r5,r1,r0
;;;156    
;;;157    	/* 硬件定时中断，定时精度us 定时器4用于Modbus */
;;;158    	bsp_StartHardTimer(4, timeout, (void *)MODBUS_RxTimeOut);
000010  4a0c              LDR      r2,|L11.68|
000012  4629              MOV      r1,r5
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       bsp_StartHardTimer
;;;159    
;;;160    	if (g_tModbus.RxCount < MODBUS_RX_SIZE)
00001a  4808              LDR      r0,|L11.60|
00001c  f8900080          LDRB     r0,[r0,#0x80]  ; g_tModbus
000020  2880              CMP      r0,#0x80
000022  da0a              BGE      |L11.58|
;;;161    	{
;;;162    		g_tModbus.RxBuf[g_tModbus.RxCount++] = _byte;
000024  4805              LDR      r0,|L11.60|
000026  f8901080          LDRB     r1,[r0,#0x80]  ; g_tModbus
00002a  f8900080          LDRB     r0,[r0,#0x80]  ; g_tModbus
00002e  1c40              ADDS     r0,r0,#1
000030  4a02              LDR      r2,|L11.60|
000032  f8820080          STRB     r0,[r2,#0x80]
000036  4610              MOV      r0,r2
000038  5444              STRB     r4,[r0,r1]
                  |L11.58|
;;;163    	}
;;;164    }
00003a  bd70              POP      {r4-r6,pc}
;;;165    
                          ENDP

                  |L11.60|
                          DCD      g_tModbus
                  |L11.64|
                          DCD      0x02160ec0
                  |L11.68|
                          DCD      MODBUS_RxTimeOut

                          AREA ||i.MODBUS_RxTimeOut||, CODE, READONLY, ALIGN=2

                  MODBUS_RxTimeOut PROC
;;;173    */
;;;174    static void MODBUS_RxTimeOut(void)
000000  2001              MOVS     r0,#1
;;;175    {
;;;176    	g_rtu_timeout = 1;
000002  4901              LDR      r1,|L12.8|
000004  7008              STRB     r0,[r1,#0]
;;;177    }
000006  4770              BX       lr
;;;178    
                          ENDP

                  |L12.8|
                          DCD      g_rtu_timeout

                          AREA ||i.MODBUS_SendWithCRC||, CODE, READONLY, ALIGN=1

                  MODBUS_SendWithCRC PROC
;;;187    */
;;;188    void MODBUS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
000002  b0a0              SUB      sp,sp,#0x80
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;190    	uint16_t crc;
;;;191    	uint8_t buf[MODBUS_TX_SIZE];
;;;192    
;;;193    	memcpy(buf, _pBuf, _ucLen);
000008  4622              MOV      r2,r4
00000a  4629              MOV      r1,r5
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;194    	crc = CRC16_Modbus(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16_Modbus
00001a  4606              MOV      r6,r0
;;;195    	buf[_ucLen++] = crc >> 8;
00001c  1232              ASRS     r2,r6,#8
00001e  4620              MOV      r0,r4
000020  1c61              ADDS     r1,r4,#1
000022  b2cc              UXTB     r4,r1
000024  f80d2000          STRB     r2,[sp,r0]
;;;196    	buf[_ucLen++] = crc;
000028  b2f2              UXTB     r2,r6
00002a  4620              MOV      r0,r4
00002c  1c61              ADDS     r1,r4,#1
00002e  b2cc              UXTB     r4,r1
000030  f80d2000          STRB     r2,[sp,r0]
;;;197    	RS485_SendBuf(buf, _ucLen);
000034  4621              MOV      r1,r4
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       RS485_SendBuf
;;;198    }
00003c  b020              ADD      sp,sp,#0x80
00003e  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tModbus
                          %        400

                          AREA ||.data||, DATA, ALIGN=0

                  g_rtu_timeout
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_modbus.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_modbus_c_a16e2304____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_modbus_c_a16e2304____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_modbus_c_a16e2304____REVSH|
#line 144
|__asm___12_bsp_modbus_c_a16e2304____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_modbus_c_a16e2304____RRX|
#line 300
|__asm___12_bsp_modbus_c_a16e2304____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
